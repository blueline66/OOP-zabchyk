# God Object та SRP

God Object — це коли один клас робить все на світі. Він і дані зберігає, і валідує, і з базою працює, і листи розсилає. Такий клас стає як "швейцарський ніж" — начебто зручно, але насправді громіздко і ненадійно. Його важко змінювати, бо коли ти чіпаєш одну функцію, може зламатись інша. Тестувати його — це жах.

Ось приклад такого класу на C#:

```csharp
public class UserManager
{
    private string _username;
    private string _email;
    
    public bool ValidateUser()
    {
        
        return true;
    }
    
    public void SaveToDatabase()
    {
        
    }
    
    public void SendEmail()
    {
        
    }
    
    public void GenerateReport()
    {
        
    }
}
```

Чому це погано? Клас `UserManager` робить забагато: він і валідатор, і робота з базою, і відправка пошти, і звіти. Кожна з цих речей може мінятися окремо. Наприклад, якщо зміниться спосіб відправки листів, ми мусимо чіпати цей великий клас. А це ризик щось зламати.

Ось як можна розбити це на дрібніші класи:

```csharp
public class User
{
    public string Username { get; set; }
    public string Email { get; set; }
}

public class UserValidator
{
    public bool Validate(User user)
    {
        
        return true;
    }
}

public class UserRepository
{
    public void Save(User user)
    {
        
    }
}

public class EmailService
{
    public void SendWelcomeEmail(User user)
    {
        
    }
}
```

Тепер кожен клас робить одну справу. `UserValidator` — тільки перевіряє, `UserRepository` — тільки зберігає, `EmailService` — тільки листи відправляє. Якщо щось зламається в email, ми знаємо, де шукати проблему. Якщо треба змінити валідацію — міняємо тільки `UserValidator`. Код стає чистішим, простішим для розуміння і безпечнішим для змін.

Головне правило: один клас — одна відповідальність. Якщо бачиш, що клас починає робити забагато — розбивай його на частини. Так код живе довше і не боліє.

# висновок
God Object — це як кухонний комбайн, який намагається бути і духовкою, і праскою, і холодильником одночасно. Здається зручно, але на практиці — ненадійно та незручно у використанні.

Коли клас робить все, він стає монолітом:
Важко змінювати (чіплеш одну функцію — ламається інша)
Неможливо нормально протестувати
Новий розробник не розбереться

SRP — це просте правило: один клас = одна задача. Не "одна велика задача", а справді одна конкретна функція. Як в кухні: плита — готує, холодильник — охолоджує, мийка — миє. Кожен інструмент робить свою справу.